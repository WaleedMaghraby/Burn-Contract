// SPDX-License-Identifier: MIT

pragma solidity 0.8.19;

import "./base/TATestBase.t.sol";
import "ta-common/TAConstants.sol";
import "ta-transaction-allocation/interfaces/ITATransactionAllocationEventsErrors.sol";
import "ta-common/interfaces/ITAHelpers.sol";
import "./modules/minimal-application/interfaces/IMinimalApplicationEventsErrors.sol";

contract TATransactionAllocationTest is
    TATestBase,
    ITATransactionAllocationEventsErrors,
    ITAHelpers,
    IMinimalApplicationEventsErrors
{
    using FixedPointTypeHelper for FixedPointType;
    using Uint256WrapperHelper for uint256;

    uint256 constant initialApplicationFunds = 10 ether;

    uint256 private _postRegistrationSnapshotId;
    uint256 private constant _initialStakeAmount = MINIMUM_STAKE_AMOUNT;
    bytes[] private txns;

    IMinimalApplication tam;

    function setUp() public override {
        if (_postRegistrationSnapshotId != 0) {
            return;
        }

        if (tx.gasprice == 0) {
            fail("Gas Price is 0. Please set it to 1 gwei or more.");
        }

        super.setUp();

        tam = IMinimalApplication(address(ta));

        uint16[] memory cdf = ta.getCdfArray(activeRelayers);

        // Register all Relayers
        for (uint256 i = 0; i < relayerCount; i++) {
            uint256 stake = _initialStakeAmount;
            string memory endpoint = "test";
            uint256 delegatorPoolPremiumShare = 100;
            RelayerAddress relayerAddress = relayerMainAddress[i];

            _startPrankRA(relayerAddress);
            bico.approve(address(ta), stake);
            vm.stopPrank();

            _register(
                relayerAddress,
                ta.getStakeArray(activeRelayers),
                ta.getDelegationArray(activeRelayers),
                stake,
                relayerAccountAddresses[relayerAddress],
                endpoint,
                delegatorPoolPremiumShare
            );
        }

        for (uint256 i = 0; i < userCount; i++) {
            txns.push(abi.encodeCall(IMinimalApplication.executeMinimalApplication, (keccak256(abi.encodePacked(i)))));
        }

        _moveForwadToNextEpoch();
        ta.processLivenessCheck(
            ITATransactionAllocation.ProcessLivenessCheckParams({
                currentCdf: cdf,
                currentActiveRelayers: new RelayerAddress[](0),
                pendingActiveRelayers: activeRelayers,
                currentActiveRelayerToPendingActiveRelayersIndex: new uint256[](0),
                latestStakeArray: ta.getStakeArray(activeRelayers),
                latestDelegationArray: ta.getDelegationArray(activeRelayers)
            })
        );
        _moveForwardByWindows(1);

        _postRegistrationSnapshotId = vm.snapshot();
    }

    function _preTestSnapshotId() internal view virtual override returns (uint256) {
        return _postRegistrationSnapshotId;
    }

    function _getRelayerAssignedToTx(bytes memory _tx, uint16[] memory _cdf)
        internal
        returns (RelayerAddress, uint256, uint256)
    {
        bytes[] memory txns_ = new bytes[](1);
        txns_[0] = _tx;

        for (uint256 i = 0; i < relayerMainAddress.length; i++) {
            RelayerAddress relayerAddress = relayerMainAddress[i];
            (bytes[] memory allotedTransactions, uint256 relayerGenerationIterations, uint256 selectedRelayerCdfIndex) =
            tam.allocateMinimalApplicationTransaction(
                AllocateTransactionParams({
                    relayerAddress: relayerAddress,
                    requests: txns_,
                    cdf: _cdf,
                    activeRelayers: activeRelayers
                })
            );

            if (allotedTransactions.length == 1) {
                return (relayerAddress, relayerGenerationIterations, selectedRelayerCdfIndex);
            }
        }

        fail("No relayer found");
        return (RelayerAddress.wrap(address(0)), 0, 0);
    }

    function testTransactionExecution() external atSnapshot {
        uint256 executionCount = 0;
        uint16[] memory cdf = ta.getCdfArray(activeRelayers);
        for (uint256 i = 0; i < relayerMainAddress.length; i++) {
            RelayerAddress relayerAddress = relayerMainAddress[i];
            (bytes[] memory allotedTransactions, uint256 relayerGenerationIterations, uint256 selectedRelayerCdfIndex) =
            tam.allocateMinimalApplicationTransaction(
                AllocateTransactionParams({
                    relayerAddress: relayerAddress,
                    requests: txns,
                    cdf: cdf,
                    activeRelayers: activeRelayers
                })
            );

            if (allotedTransactions.length == 0) {
                continue;
            }

            _startPrankRAA(relayerAccountAddresses[relayerMainAddress[i]][0]);
            ta.execute(
                ITATransactionAllocation.ExecuteParams({
                    reqs: allotedTransactions,
                    forwardedNativeAmounts: new uint256[](allotedTransactions.length),
                    cdf: cdf,
                    activeRelayers: activeRelayers,
                    relayerIndex: selectedRelayerCdfIndex,
                    relayerGenerationIterationBitmap: relayerGenerationIterations
                })
            );
            vm.stopPrank();

            executionCount += allotedTransactions.length;
        }

        assertEq(executionCount, txns.length);
        assertEq(tam.count(), executionCount);
    }

    function testCannotExecuteTransactionWithInvalidCdf() external atSnapshot {
        uint16[] memory cdf = ta.getCdfArray(activeRelayers);
        uint16[] memory cdf2 = ta.getCdfArray(activeRelayers);
        // Corrupt the CDF
        cdf2[0] += 1;

        for (uint256 i = 0; i < relayerMainAddress.length; i++) {
            RelayerAddress relayerAddress = relayerMainAddress[i];
            (bytes[] memory allotedTransactions, uint256 relayerGenerationIterations, uint256 selectedRelayerCdfIndex) =
            tam.allocateMinimalApplicationTransaction(
                AllocateTransactionParams({
                    relayerAddress: relayerAddress,
                    requests: txns,
                    cdf: cdf,
                    activeRelayers: activeRelayers
                })
            );

            if (allotedTransactions.length == 0) {
                continue;
            }

            _startPrankRAA(relayerAccountAddresses[relayerMainAddress[i]][0]);
            vm.expectRevert(InvalidCdfArrayHash.selector);
            ta.execute(
                ITATransactionAllocation.ExecuteParams({
                    reqs: allotedTransactions,
                    forwardedNativeAmounts: new uint256[](allotedTransactions.length),
                    cdf: cdf2,
                    activeRelayers: activeRelayers,
                    relayerIndex: selectedRelayerCdfIndex,
                    relayerGenerationIterationBitmap: relayerGenerationIterations
                })
            );
            vm.stopPrank();
        }
    }

    function testCannotExecuteTransactionFromUnselectedRelayer() external atSnapshot {
        uint16[] memory cdf = ta.getCdfArray(activeRelayers);

        for (uint256 i = 0; i < relayerMainAddress.length; i++) {
            RelayerAddress relayerAddress = relayerMainAddress[i];
            (bytes[] memory allotedTransactions, uint256 relayerGenerationIterations, uint256 selectedRelayerCdfIndex) =
            tam.allocateMinimalApplicationTransaction(
                AllocateTransactionParams({
                    relayerAddress: relayerAddress,
                    requests: txns,
                    cdf: cdf,
                    activeRelayers: activeRelayers
                })
            );

            if (allotedTransactions.length == 0) {
                continue;
            }

            uint256 testRelayerIndex = (i + 1) % relayerMainAddress.length;

            _startPrankRAA(relayerAccountAddresses[relayerMainAddress[testRelayerIndex]][0]);
            vm.expectRevert(RelayerIndexDoesNotPointToSelectedCdfInterval.selector);
            ta.execute(
                ITATransactionAllocation.ExecuteParams({
                    reqs: allotedTransactions,
                    forwardedNativeAmounts: new uint256[](allotedTransactions.length),
                    cdf: cdf,
                    activeRelayers: activeRelayers,
                    relayerIndex: selectedRelayerCdfIndex + 1,
                    relayerGenerationIterationBitmap: relayerGenerationIterations
                })
            );
            vm.stopPrank();
        }
    }

    // TODO: This test is suspicious
    function testCannotExecuteTransactionFromSelectedButNonAllotedRelayer() external atSnapshot {
        uint16[] memory cdf = ta.getCdfArray(activeRelayers);
        (RelayerAddress[] memory selectedRelayers,) = ta.allocateRelayers(cdf, activeRelayers);
        bool testRun = false;

        for (uint256 i = 0; i < relayerMainAddress.length; i++) {
            RelayerAddress relayerAddress = relayerMainAddress[i];
            (bytes[] memory allotedTransactions, uint256 relayerGenerationIterations, uint256 selectedRelayerCdfIndex) =
            tam.allocateMinimalApplicationTransaction(
                AllocateTransactionParams({
                    relayerAddress: relayerAddress,
                    requests: txns,
                    cdf: cdf,
                    activeRelayers: activeRelayers
                })
            );

            if (allotedTransactions.length == 0) {
                continue;
            }

            if (selectedRelayers[0] == relayerAddress) {
                continue;
            }

            testRun = true;

            _startPrankRAA(relayerAccountAddresses[selectedRelayers[0]][0]);
            vm.expectRevert(RelayerIndexDoesNotPointToSelectedCdfInterval.selector);
            ta.execute(
                ITATransactionAllocation.ExecuteParams({
                    reqs: allotedTransactions,
                    forwardedNativeAmounts: new uint256[](allotedTransactions.length),
                    cdf: cdf,
                    activeRelayers: activeRelayers,
                    relayerIndex: selectedRelayerCdfIndex + 1,
                    relayerGenerationIterationBitmap: relayerGenerationIterations
                })
            );
            vm.stopPrank();
        }

        assertEq(testRun, true);
    }

    ////// Liveness Check Tests //////
    function _calculatePenalty(uint256 _stake) internal pure returns (uint256) {
        return (_stake * ABSENCE_PENALTY) / (100 * PERCENTAGE_MULTIPLIER);
    }

    function testMinimumTransactionForLivenessCalculation() external atSnapshot {
        FixedPointType minTransactions =
            ta.calculateMinimumTranasctionsForLiveness(10 ** 18, 2 * 10 ** 18, uint256(50).fp(), LIVENESS_Z_PARAMETER);
        assertEq(minTransactions.u256(), 24);

        minTransactions =
            ta.calculateMinimumTranasctionsForLiveness(10 ** 18, 5 * 10 ** 18, uint256(50).fp(), LIVENESS_Z_PARAMETER);
        assertEq(minTransactions.u256(), 9);
    }

    function testPenalizeRelayerIfInsufficientTransactionAreSubmitted() external atSnapshot {
        RelayerAddress activeRelayer = relayerMainAddress[0];
        ta.debug_setTotalTransactionsProcessed(100);
        ta.debug_setTransactionsProcessedByRelayer(activeRelayer, 10);

        uint16[] memory cdf = ta.getCdfArray(activeRelayers);
        uint32[] memory stakeArray = ta.getStakeArray(activeRelayers);
        uint32[] memory delegationArray = ta.getDelegationArray(activeRelayers);

        for (uint256 i = 0; i < activeRelayers.length; ++i) {
            if (activeRelayers[i] == activeRelayer) {
                continue;
            }

            vm.expectEmit(true, true, true, false);
            emit RelayerPenalized(activeRelayers[i], _calculatePenalty(ta.relayerInfo(activeRelayers[i]).stake));
        }
        uint256[] memory relayerIndexMapping = new uint256[](activeRelayers.length);
        for (uint256 i = 0; i < activeRelayers.length; ++i) {
            relayerIndexMapping[i] = i;
        }

        ta.processLivenessCheck(
            ITATransactionAllocation.ProcessLivenessCheckParams({
                currentCdf: cdf,
                currentActiveRelayers: activeRelayers,
                pendingActiveRelayers: activeRelayers,
                currentActiveRelayerToPendingActiveRelayersIndex: relayerIndexMapping,
                latestStakeArray: stakeArray,
                latestDelegationArray: delegationArray
            })
        );
    }
}
